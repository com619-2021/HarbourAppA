PilotInventoryServiceImpl:
package org.solent.com504.project.impl.resource.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.solent.com504.project.model.dto.ReplyMessage;
import org.solent.com504.project.model.resource.dto.AbstractPilotMapper;
import org.solent.com504.project.model.resource.dto.PilotAccess;
import org.solent.com504.project.model.resource.dto.PilotCatalog;
import org.solent.com504.project.model.resource.dto.PilotCharacteristics;
import org.solent.com504.project.model.resource.service.PilotInventoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;


public class PilotInventoryServiceImpl implements PilotInventoryService {
    final static Logger LOG = LogManager.getLogger(PilotInventoryServiceImpl.class);

    @Autowired
    private PilotRepository pilotRepository = null;

    @Autowired
    private PilotRepository pilotRepository = null;

    @Autowired
    private PilotCatalogRepository pilotCatalogRepository = null;

    @Override
    @Transactional
    public ReplyMessage getPilotByuuid(String uuid) {
        ReplyMessage replyMessage = new ReplyMessage();

        List<Pilot> resourceList = pilotRepository.findByUuid(uuid);
        if (resourceList.isEmpty()) {
            throw new IllegalArgumentException("cannot find pilot uuid not found=" + uuid);
        }
        Pilot pilotEntity = pilotList.get(0);

        Pilot detachedPilot = AbstractPilotMapper.INSTANCE.abstractPilotToPilot(pilotEntity);
        replyMessage.setPilotList(Arrays.asList(detachedPilot));
        replyMessage.setOffset(0);
        replyMessage.setLimit(1);
        replyMessage.setTotalCount(1L);
        return replyMessage;
    }

    @Override
    @Transactional
    public ReplyMessage deletePilotByUuid(String uuid) {
        List<Pilot> pilotList = pilotRepository.findByUuid(uuid);
        if (pilotList.isEmpty()) {
            throw new IllegalArgumentException("cannot delete pilot uuid not found=" + uuid);
        }
        pilotRepository.delete(pilotList.get(0));
        return new ReplyMessage();
    }

    @Override
    @Transactional
    public ReplyMessage postCreatePilot(Pilot pilot, String ownerPilotUUID) {
        pilot.setId(null);
        List<Pilot> partyList = pilotRepository.findByUuid(ownerPilotUUID);
        if (pilotList.isEmpty()) {
            throw new IllegalArgumentException("cannot create pilot party not found ownerPartyUUID=" + ownerpilotUUID);
        } else {
            Pilot pilotOwner = pilotList.get(0);
            pilot.setPilotOwner(pilotOwner);
            
            if (pilot.getUuid() == null || pilot.getUuid().isEmpty()) {
                pilot.setUuid(UUID.randomUUID().toString());
                pilot.setResourceController(PilotAccess.INTERNAL);
            }
            pilot = pilotRepository.saveAndFlush(pilot);
        }

        ReplyMessage replyMessage = new ReplyMessage();
        replyMessage.setPilotList(Arrays.asList(pilot));
        return replyMessage;
    }

    @Override
    public ReplyMessage postCreatePilotFromCatalogPilot(String catalogUUID, String ownerPilotUUID) {
        
        List<PilotCatalog> pilotCatalogList = pilotCatalogRepository.findByUuid(catalogUUID);
        if (pilotCatalogList.isEmpty()) {
            throw new IllegalArgumentException("cannot create pilot catalog entry not found uuid=" + catalogUUID);
        }
        PilotCatalog pilotCatalog = pilotCatalogList.get(0);

        Pilot pilot = AbstractPilotMapper.INSTANCE.abstractPilotToPilot(pilotCatalog);
        
        Long t = new Date().getTime();
        pilot.setName("update pilot name " + t);
        pilot.setId(null);

        ReplyMessage replyMessage = postCreatePilot(pilot, ownerPartyUUID);
        return replyMessage;
    }

    @Override
    @Transactional
    public ReplyMessage putUpdatePilot(Pilot pilot) {
        pilot.setId(null);
        if (pilot.getUuid() == null) {
            throw new IllegalArgumentException("cannot update pilot uuid=null");
        }
        List<Pilot> pilotList = pilotRepository.findByUuid(pilot.getUuid());
        if (pilotList.isEmpty()) {
            throw new IllegalArgumentException("cannot update pilot not found uuid=" + pilot.getUuid());
        }
        Pilot pilotEntity = pilotList.get(0);

        pilotEntity = AbstractPilotMapper.INSTANCE.updatePilot(pilot, pilotEntity);
        pilotEntity = pilotRepository.saveAndFlush(pilotEntity);

        Pilot detachedPilot = AbstractPilotMapper.INSTANCE.abstractPilotToPilot(pilotEntity);
        ReplyMessage replyMessage = new ReplyMessage();
        replyMessage.setOffset(1);
        replyMessage.setLimit(1);
        replyMessage.setTotalCount(1L);
        replyMessage.setResourceList(Arrays.asList(detachedPilot));
        return replyMessage;
    }

    @Override
    @Transactional
    public ReplyMessage postAddModifyPilotCharacteristics(String pilotUuid, String name, String license, Boolean availability) {
        List<Pilot> pilotList = pilotRepository.findByUuid(pilotUuid);
        if (pilotList != null && !pilotList.isEmpty()) {
            Pilot pilotEntity = pilotList.get(0);
            List<PilotCharacteristics> characteristics = (pilotEntity.getPilotCharacteristics() != null) ? pilotEntity.getPilotCharacteristics() : new ArrayList<PilotCharacteristics>();

            if (pilotEntity.getPilotCharacteristics() != null) {
                for (Object o : pilotEntity.getCharacteristics()) {
                    LOG.debug("******************x 0=" + o);
                    LOG.debug("***************type 0=" + o.getClass().getCanonicalName());
                }
            } else {
                LOG.debug("****************** 0=null !!");
            }

            Iterator<PilotCharacteristics> iterator = characteristics.iterator();
            boolean found = false;
            PilotCharacteristics characteristic;
            while (iterator.hasNext() && !found) {
                characteristic = iterator.next();
                if (name.equals(characteristic.getName())) {

                    found = true;
                    characteristic.setAvailability(availability);
                    characteristic.setLicense(license);
                }
            }

            if (!found) {
                characteristic = new PilotCharacteristics(name, license, availability);
                characteristic.setAvailability(availability);
                characteristic.setLicense(license);
                characteristics.add(characteristic);
            }
            pilotEntity.setPilotCharacteristics(characteristics);
            pilotRepository.saveAndFlush(pilotEntity);

            Pilot detachedResource = AbstractPilotMapper.INSTANCE.abstractPilotToPilot(pilotEntity);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setPilotList(Arrays.asList(detachedPilot));
            return replyMessage;
        } else {
            throw new IllegalArgumentException("error updating characteristic " + name + " resource not found pilotUuid=" + pilotUuid);
        }
    }
}
PilotCatalogRestService:
package org.solent.com504.project.impl.rest;

import io.swagger.v3.oas.annotations.Operation;
import javax.ws.rs.Path;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.solent.com504.project.model.resource.service.PilotCatalogService;
import org.solent.com504.project.model.resource.service.PilotInventoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component // component allows resource to be picked up
@Path("/solent-api/pilot/v1/")
public class PilotCatalogRestService {
    final static Logger LOG = LogManager.getLogger(PilotCatalogRestService.class);

    @Autowired
    PilotCatalogService pilotCatalogService = null;

    @Autowired
    PilotInventoryService pilotService = null;

    @Autowired
    private PilotService pilotService;

    @Operation(summary = "Find catalog pilot by uuid",
            tags = {"pilot/catalog"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "404", description = "not found"),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @GET
    @Path("/catalog/{uuid}")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Transactional(readOnly = true)
    public Response getPilotCatalogByuuid(@PathParam("uuid") String uuid, @Context UriInfo uriInfo) {
        try {
            throw new UnsupportedOperationException("Not supported yet."); 

        } catch (Exception ex) {
            LOG.error("error calling GET /catalog/{uuid} getPilotCatalogByuuid uuid=" + uuid, ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling GET /catalog/{uuid} getPilotCatalogByuuid uuid=" + uuid + " " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

    @Operation(summary = "Delete catalog pilot by uuid",
            tags = {"pilot/catalog"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "404", description = "not found"),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @DELETE
    @Path("/catalog/{uuid}")
    @Transactional()
    public Response deletePilotCatalogByUuid(@PathParam("uuid") String uuid, @Context UriInfo uriInfo) {
        try {
            throw new UnsupportedOperationException("Not supported yet.");

        } catch (Exception ex) {
            LOG.error("error calling DELETE /catalog/{uuid} getPilotCatalogByuuid uuid=" + uuid, ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling DELETE /catalog/{uuid} getPilotCatalogByuuid uuid=" + uuid + " " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

    @Operation(summary = "Create new Catalog pilot",
            tags = {"pilot/catalog"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @POST
    @Path("/catalog")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Transactional
    public Response postCreateResourceCatalog(Pilot pilot, @Context UriInfo uriInfo) {
        try {
            throw new UnsupportedOperationException("Not supported yet.");

        } catch (Exception ex) {
            LOG.error("error calling POST /catalog postCreatePilotCatalog ", ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling POST /catalog postCreatePilotCatalog " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

    @Operation(summary = "update  Catalog pilot",
            tags = {"pilot/catalog"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "404", description = "not found"),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @PUT
    @Path("/catalog")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Transactional
    public Response putUpdateResourceCatalog(Pilot pilot, @Context UriInfo uriInfo) {
        try {
            throw new UnsupportedOperationException("Not supported yet."); 

        } catch (Exception ex) {
            LOG.error("error calling PUT /catalog putUpdatePilotCatalog ", ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling PUT /catalog putUpdatePilotCatalog " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

}
PilotInventoryRestService:
package org.solent.com504.project.impl.rest;

import javax.ws.rs.Path;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.solent.com504.project.model.resource.service.PilotInventoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component // component allows resource to be picked up
@Path("/solent-api/pilot/v1/")
public class PilotInventoryRestService {
    final static Logger LOG = LogManager.getLogger(PilotInventoryRestService.class);

    @Autowired
    PilotCatalogService pilotCatalogService = null;

    @Autowired
    PilotInventoryService pilotInventoryService = null;

    @Autowired
    private PilotService pilotService;

    @Operation(summary = "Find catalog pilot by uuid",
            tags = {"pilot/inventory"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "404", description = "not found"),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @GET
    @Path("/inventory/{uuid}")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Transactional(readOnly = true)
    public Response getPilotInventoryByuuid(@PathParam("uuid") String uuid, @Context UriInfo uriInfo) {
        try {
            ReplyMessage replyMessage = pilotInventoryService.getPilotByuuid(uuid);
            replyMessage.setCode(Pilot.Status.OK.getStatusCode());
            return Response.status(Response.Status.OK).entity(replyMessage).build();

        } catch (Exception ex) {
            LOG.error("error calling GET /inventory/{uuid} getPilotInventoryByuuid uuid=" + uuid, ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling GET /inventory/{uuid} getPilotInventoryByuuid uuid=" + uuid + " " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

    @Operation(summary = "Delete pilot by uuid",
            tags = {"pilot/inventory"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "404", description = "not found"),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @DELETE
    @Path("/inventory/{uuid}")
    @Transactional()
    public Response deletePilotInventoryByUuid(@PathParam("uuid") String uuid, @Context UriInfo uriInfo) {
        try {
            ReplyMessage replyMessage = pilotInventoryService.deletePilotByUuid(uuid);
            replyMessage.setCode(Response.Status.OK.getStatusCode());
            return Response.status(Response.Status.OK).entity(replyMessage).build();

        } catch (Exception ex) {
            LOG.error("error calling DELETE /inventory/{uuid} getPilotInventoryByuuid uuid=" + uuid, ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling DELETE /inventory/{uuid} getPilotInventoryByuuid uuid=" + uuid + " " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

    @Operation(summary = "Create new pilot",
            tags = {"pilot/inventory"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @POST
    @Path("/inventory")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Transactional
    public Response postCreatePilotInventory(Pilot resource, @Context UriInfo uriInfo) {
        try {
            throw new UnsupportedOperationException("Not supported yet.");

        } catch (Exception ex) {
            LOG.error("error calling POST /inventory postCreatePilotInventory ", ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling POST /inventory postCreatePilotInventory " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

    @Operation(summary = "update  Catalog pilot",
            tags = {"pilot/inventory"},
            responses = {
                @ApiResponse(responseCode = "200", description = "successful operation returns pilot list with one entry", content = @Content(
                        schema = @Schema(implementation = ReplyMessage.class))),
                @ApiResponse(responseCode = "404", description = "not found"),
                @ApiResponse(responseCode = "500", description = "internal server error")
            })
    @PUT
    @Path("/inventory")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    @Transactional
    public Response putUpdatePilotInventory(Pilot pilot, @Context UriInfo uriInfo) {
        try {
            throw new UnsupportedOperationException("Not supported yet.");

        } catch (Exception ex) {
            LOG.error("error calling PUT /inventory putUpdateResourceInventory ", ex);
            ReplyMessage replyMessage = new ReplyMessage();
            replyMessage.setCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());
            replyMessage.setDebugMessage("error calling PUT /inventory putUpdatePilotInventory " + ex.getMessage());
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(replyMessage).build();
        }
    }

}
PilotRepository:
package org.solent.com504.project.impl.dao.resource.springdata;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PilotRepository extends JpaRepository<Pilot, Long>, JpaSpecificationExecutor<Pilot> {
    @Query("select r from Pilot r  where r.uuid = :uuid")
    public List<Pilot> findByUuid(@Param("uuid") String uuid);
}
PilotCatalogRepository:
package org.solent.com504.project.impl.dao.resource.springdata;

import java.util.List;
import org.solent.com504.project.model.resource.dto.PilotCatalog;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PilotCatalogRepository extends JpaRepository<PilotCatalog, Long>, JpaSpecificationExecutor<PilotCatalog> {
    @Query("select c from PilotCatalog c  where c.uuid = :uuid")
    public List<PilotCatalog> findByUuid(@Param("uuid") String uuid);
}
PilotController:
package org.solent.com504.project.impl.web;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.solent.com504.project.model.resource.dto.PilotAccess;
import org.solent.com504.project.model.user.dto.Role;
import org.solent.com504.project.model.user.dto.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@Transactional
public class PilotController {
    final static Logger LOG = LogManager.getLogger(PilotController.class);

    {
        LOG.debug("PilotController created");
    }

    @Autowired
    private UserService userService;

    @Autowired
    private PilotService pilotService;

    @Autowired
    private SecurityService securityService;

    @Autowired
    private UserValidator userValidator;

    @Autowired
    private PilotCatalogService pilotCatalogService = null;

    @Autowired
    private PilotInventoryService pilotService = null;

    @RequestMapping(value = {"/pilot"}, method = RequestMethod.GET)
    public String pilots(Model model) {
        LOG.debug("pilot called:");
        List<Pilot> pilotList = reply.getPilotList();

        model.addAttribute("abstractPilotListSize", pilotList.size());
        model.addAttribute("abstractPilotList", pilotList);

        List<PilotCatalog> catalogList;
        ReplyMessage replyMessage = pilotCatalogService.getPilotCatalogByTemplate(null, 0, 100);
        catalogList = replyMessage.getPilotCatalogList();
        model.addAttribute("catalogListSize", catalogList.size());
        model.addAttribute("catalogList", catalogList);


        List<Pilot> partyList = PilotService.findAll();
        model.addAttribute("pilotListSize", pilotList.size());
        model.addAttribute("pilotList", pilotList);

        model.addAttribute("selectedPage", "pilot");
        return "pilots";
    }

    @RequestMapping(value = {"/viewModifyPilot"}, method = RequestMethod.GET)
    public String viewpilot(Model model,
            @RequestParam(value = "abstractPilotUuid", required = true) String abstractPilotUuid, Authentication authentication) {

        LOG.debug("/viewModifyPilot: abstractPilotUuid:" + abstractPilotUuid);
        String errorMessage = "";
        String message = "";

        Pilot abstractPilot = new Pilot();
        List<PilotCharacteristics> abstractCharacteristics = new ArrayList();


        List<Pilot> pilotList = new ArrayList();
        ReplyMessage replyMessage = pilotService.getPilotByuuid(abstractPilotUuid);
        if (replyMessage.getPilotList() != null && !replyMessage.getPilotList().isEmpty()) {
            pilotList = replyMessage.getPilotList();
            abstractPilot = pilotList.get(0);
            abstractCharacteristics = (abstractPilot.getCharacteristics() != null) ? abstractPilot.getPilotCharacteristics() : abstractCharacteristics;
        } else {
            errorMessage = "error getting resource" + replyMessage.getDebugMessage();
            model.addAttribute("errorMessage", errorMessage);
        }

        model.addAttribute("abstractPilotSize", resourceList.size());
        model.addAttribute("abstractPilot", abstractPilot);
        model.addAttribute("abstractPilotCharacteristics", abstractCharacteristics);

        // add message if there are any 
        model.addAttribute("errorMessage", errorMessage);
        model.addAttribute("message", message);

        model.addAttribute("selectedPage", "pilots");
        return "viewModifyPilot";
    }

    @RequestMapping(value = {"/viewModifyPilot"}, method = RequestMethod.POST)
    public String updateresource(Model model,
            @RequestParam(value = "action", required = true) String action,
            @RequestParam(value = "abstractPilotUuid", required = false) String abstractPilotUuid,
            @RequestParam(value = "abstractPilotName", required = false) String abstractPilotName,
            @RequestParam(value = "abstractName", required = false) String abstractName,
            @RequestParam(value = "abstractPilotHref", required = false) String abstractResourceHref,
            @RequestParam(value = "abstractPilotPilotController", required = false) String abstractPilotPilotController,
            @RequestParam(value = "abstractPilotDescription", required = false) String abstractPilotDescription,
            @RequestParam(value = "characteristicName", required = false) String characteristicName,
            @RequestParam(value = "characteristicLicense", required = false) String characteristicLicense,
            @RequestParam(value = "characteristicAvailability", required = false) String characteristicAvailability,
            @RequestParam(value = "ownerPilotUUID", required = false) String ownerPartyUUID,
            @RequestParam(value = "catalogUUID", required = false) String catalogUUID,
            Authentication authentication) {

        LOG.debug("/viewModifyPilot: abstractPilotUuid:" + abstractPilotUuid);

        String errorMessage = "";
        String message = "";

        Pilot abstractPilot = new Pilot();
        List<PilotCharacteristics> abstractCharacteristics = new ArrayList();
        ReplyMessage replyMessage;

        if ("createAbstractPilot".equals(action)) {

            replyMessage = pilotService.postCreatePilotFromCatalogPilot(catalogUUID, ownerPilotUUID);
            if (replyMessage.getPilotList() != null && !replyMessage.getPilotList().isEmpty()) {
                abstractPilot = replyMessage.getPilotList().get(0);
                abstractPilotUuid = abstractPilot.getUuid();
                message = "success created pilot uuid=" + abstractPilotUuid;
            } else {
                errorMessage = "error creating resource" + replyMessage.getDebugMessage();
            }
            LOG.debug("creating Pilot: abstractPilotUuid=" + abstractPilotUuid);

        } else if ("updateAbstractPilot".equals(action)) {
            Pilot pilot = new Pilot();
            pilot.setUuid(abstractPilotUuid);
            pilot.setName(abstractPilotName);
            pilot.setPilotName(abstractName);
            pilot.setHref(abstractResourceHref);
            PilotAccess pilotAccess = PilotAccess.valueOf(abstractPilotPilotController);
            pilot.setResourceController(pilotAccess);
            pilot.setAvailability(abstractPilotDescription);

            pilotService.putUpdatePilot(pilot);
            message = "success updated";

        } else if ("deleteAbstractPilot".equals(action)) {
            replyMessage = pilotService.deletePilotByUuid(abstractPilotUuid);
            return "redirect:/pilot";

        } else if ("deleteCharacteristic".equals(action)) {
            replyMessage = pilotService.postRemoveCharacteristic(abstractPilotUuid, characteristicName);
            message = "success characteristic " + characteristicName + " deleted";

        } else if ("updateCharacteristic".equals(action)) {
            replyMessage = pilotService.postAddModifyCharacteristic(abstractPilotUuid, characteristicName, characteristicLicense, characteristicAvailability);
            message = "success characteristic " + characteristicName + " updated";

        } else if ("createCharacteristic".equals(action)) {
            if (characteristicName.isEmpty()) {
                errorMessage = "characteristic name cannot be blank";
            } else {
                replyMessage = pilotService.postAddModifyCharacteristic(abstractPilotUuid, characteristicName, characteristicLicense, characteristicAvailability);
                message = "success characteristic " + characteristicName + " added";
            }
        }


        List<Pilot> pilotList = new ArrayList();
        replyMessage = pilotService.getPilotByuuid(abstractPilotUuid);
        if (replyMessage.getPilotList() != null && !replyMessage.getPilotList().isEmpty()) {
            pilotList = replyMessage.getPilotList();
            abstractPilot = pilotList.get(0);
            abstractCharacteristics = (abstractPilot.getCharacteristics() != null) ? abstractPilot.getPilotCharacteristics() : abstractCharacteristics;
        } else {
            errorMessage = "error creating pilot" + replyMessage.getDebugMessage();
        }
        model.addAttribute("abstractPilotSize", pilotList.size());
        model.addAttribute("abstractPilot", abstractPilot);
        model.addAttribute("abstractCharacteristics", abstractCharacteristics);


        model.addAttribute("errorMessage", errorMessage);
        model.addAttribute("message", message);

        model.addAttribute("selectedPage", "pilot");
        return "viewModifyPilot";
    }

    private Map<String, String> selectedRolesMap(User user) {

        List<String> availableRoles = userService.getAvailableUserRoleNames();

        List<String> selectedRoles = new ArrayList();
        for (Role role : user.getRoles()) {
            selectedRoles.add(role.getName());
            LOG.debug("user " + user.toString()
                    + "roles from database:" + role.getName());
        }

        Map<String, String> selectedRolesMap = new LinkedHashMap();
        for (String availableRole : availableRoles) {
            if (selectedRoles.contains(availableRole)) {
                selectedRolesMap.put(availableRole, "checked");
                LOG.debug("availableRole " + availableRole
                        + " user " + user.toString() + " available role:checked");
            } else {
                selectedRolesMap.put(availableRole, "");
                LOG.debug("availableRole " + availableRole
                        + " user " + user.toString() + " available role:not checked");
            }
        }

        return selectedRolesMap;

    }

    private boolean hasRole(String role) {
        Collection<GrantedAuthority> authorities
                = (Collection<GrantedAuthority>) SecurityContextHolder.getContext().getAuthentication().getAuthorities();
        boolean hasRole = false;
        for (GrantedAuthority authority : authorities) {
            hasRole = authority.getAuthority().equals(role);
            if (hasRole) {
                break;
            }
        }
        return hasRole;
    }
}
